function e(e,t){return function(e,t){return t.get?t.get.call(e):t.value}(e,s(e,t,"get"))}function t(e,t,n){return function(e,t,s){if(t.set)t.set.call(e,s);else{if(!t.writable)throw new TypeError("attempted to set read only private field");t.value=s}}(e,s(e,t,"set"),n),n}function s(e,t,s){if(!t.has(e))throw new TypeError("attempted to "+s+" private field on non-instance");return t.get(e)}const n=/\s+/;function r(e,t,s,i,o){let a,h=0;if(s&&"object"==typeof s){void 0!==i&&"context"in o&&void 0===o.context&&(o.context=i);for(a=c(s);h<a.length;h++)t=r(e,t,a[h],s[a[h]],o)}else if(s&&n.test(s))for(a=s.split(n);h<a.length;h++)t=e(t,a[h],i,o);else t=e(t,s,i,o);return t}function i(e){const t=e.name;return""!==t?`[${t}] `:""}function o(e,t,s,n){const r=n.events;if(r){const s=r[t];if(Array.isArray(s))for(const t of s)t.options.guard&&(e.guard=!0),t.options.type>e.type&&(e.type=t.options.type)}return e}const c=e=>null===e||"object"!=typeof e?[]:Object.keys(e);function a(e,t,s,n){const r=n.after,i=n.count+1;if(s){const n=e[t]=h(i,(function(){return s.apply(this,arguments)}),(()=>{r(t,n)}));n._callback=s}return e}const h=function(e,t,s){let n;return function(...r){return--e>0&&(n=t.apply(this,r)),e<=1&&(s&&s.apply(this,r),s=void 0,t=void 0),n}};var l=new WeakMap,f=new WeakMap;class u{constructor(e=""){if(l.set(this,{writable:!0,value:""}),f.set(this,{writable:!0,value:void 0}),"string"!=typeof e)throw new TypeError("'name' is not a string");t(this,l,e),this._listeners=void 0,this._listenId=void 0,this._listeningTo=void 0}before(e,t,s,n,o={}){if(!Number.isInteger(e))throw new TypeError("'count' is not an integer");const c={};if(this.isGuarded(t,c))return console.warn(`@typhonjs-plugin/eventbus ${i(this)}- before() failed as event name(s) are guarded: ${JSON.stringify(c.names)}`),this;const h=r(a,{},t,s,{count:e,after:this.off.bind(this)});return"string"==typeof t&&null==n&&(s=void 0),this.on(h,s,n,o)}*entries(t){if(void 0!==t&&!(t instanceof RegExp))throw new TypeError("'regex' is not a RegExp");if(e(this,f))if(t){for(const s in e(this,f))if(t.test(s))for(const t of e(this,f)[s])yield[s,t.callback,t.context,JSON.parse(JSON.stringify(t.options))]}else for(const t in e(this,f))for(const s of e(this,f)[t])yield[t,s.callback,s.context,JSON.parse(JSON.stringify(s.options))]}get eventCount(){return e(this,f)?Object.keys(e(this,f)).length:0}get callbackCount(){if(!e(this,f))return 0;let t=0;for(const s in e(this,f))t+=e(this,f)[s].length;return t}getOptions(t){const s=r(o,{guard:!1,type:0},t,void 0,{events:e(this,f)});let n;switch(s.type){case 1:n="sync";break;case 2:n="async"}return{guard:s.guard,type:n}}getType(t){switch(r(x,{type:0},t,void 0,{events:e(this,f)}).type){case 1:return"sync";case 2:return"async";default:return}}isGuarded(t,s={}){return s.names=[],s.guarded=!1,r(k,s,t,void 0,{events:e(this,f)}).guarded}*keys(t){if(void 0!==t&&!(t instanceof RegExp))throw new TypeError("'regex' is not a RegExp");if(e(this,f))if(t)for(const s in e(this,f))t.test(s)&&(yield s);else for(const t in e(this,f))yield t}*keysWithOptions(t){if(void 0!==t&&!(t instanceof RegExp))throw new TypeError("'regex' is not a RegExp");if(e(this,f))if(t)for(const s in e(this,f))t.test(s)&&(yield[s,this.getOptions(s)]);else for(const t in e(this,f))yield[t,this.getOptions(t)]}get name(){return e(this,l)}listenTo(e,t,s){if(!e)return this;const n={};if(N(e,t,n))return console.warn(`@typhonjs-plugin/eventbus ${i(this)}- listenTo() failed as event name(s) are guarded for target object: ${JSON.stringify(n.names)}`),this;const r=e._listenId||(e._listenId=A("l")),o=this._listeningTo||(this._listeningTo={});let c=d=o[r];c||(this._listenId||(this._listenId=A("l")),c=d=o[r]=new E(this,e));const a=j(e,t,s,this);if(d=void 0,a)throw a;return c.interop&&c.on(t,s),this}listenToBefore(e,t,s,n){if(!Number.isInteger(e))throw new TypeError("'count' is not an integer");const i=r(a,{},s,n,{count:e,after:this.stopListening.bind(this,t)});return this.listenTo(t,i)}listenToOnce(e,t,s){const n=r(a,{},t,s,{count:1,after:this.stopListening.bind(this,e)});return this.listenTo(e,n)}off(s,n,i){return e(this,f)?(t(this,f,r(T,e(this,f),s,n,{context:i,listeners:this._listeners})),this):this}on(s,n,o,c={}){if(null==c||c.constructor!==Object)throw new TypeError("'options' must be an object literal.");const a={};return this.isGuarded(s,a)?(console.warn(`@typhonjs-plugin/eventbus ${i(this)}- on() failed as event name(s) are guarded: ${JSON.stringify(a.names)}`),this):(t(this,f,r(R,e(this,f)||{},s,n,{context:o,ctx:this,options:c,listening:d})),d&&((this._listeners||(this._listeners={}))[d.id]=d,d.interop=!1),this)}once(e,t,s,n={}){const o={};if(this.isGuarded(e,o))return console.warn(`@typhonjs-plugin/eventbus ${i(this)}- once() failed as event name(s) are guarded: ${JSON.stringify(o.names)}`),this;const c=r(a,{},e,t,{count:1,after:this.off.bind(this)});return"string"==typeof e&&null==s&&(t=void 0),this.on(c,t,s,n)}stopListening(e,t,s){const n=this._listeningTo;if(!n)return this;const r=e?[e._listenId]:c(n);for(let e=0;e<r.length;e++){const i=n[r[e]];if(!i)break;i.obj.off(t,s,this),i.interop&&i.off(t,s)}return this}trigger(t,...s){return e(this,f)?(O(m,D,e(this,f),t,void 0,s),this):this}async triggerAsync(t,...s){if(!e(this,f))return;const n=O(m,S,e(this,f),t,void 0,s);return void 0!==n?Array.isArray(n)?Promise.all(n).then((e=>{let t=[];for(const s of e)Array.isArray(s)?t=t.concat(s):void 0!==s&&t.push(s);return t.length>1?t:1===t.length?t[0]:void 0})):n:void 0}triggerDefer(e,...t){return setTimeout((()=>{this.trigger(e,...t)}),0),this}triggerSync(t,...s){if(e(this,f))return O(m,P,e(this,f),t,void 0,s)}}let d;var y=new WeakMap,g=new WeakMap,p=new WeakMap,b=new WeakMap,v=new WeakMap,w=new WeakMap;class E{constructor(e,s){y.set(this,{writable:!0,value:void 0}),g.set(this,{writable:!0,value:void 0}),p.set(this,{writable:!0,value:void 0}),b.set(this,{writable:!0,value:void 0}),v.set(this,{writable:!0,value:void 0}),w.set(this,{writable:!0,value:0}),t(this,g,e._listenId),t(this,p,e),t(this,b,s),t(this,v,!0)}cleanup(){delete e(this,p)._listeningTo[e(this,b)._listenId],e(this,v)||delete e(this,b)._listeners[e(this,g)]}get id(){return e(this,g)}get interop(){return e(this,v)}get obj(){return e(this,b)}incrementCount(){t(this,w,+e(this,w)+1)}on(s,n,i){return t(this,y,r(R,e(this,y)||{},s,n,{context:i,ctx:this,options:{},listening:this})),this}off(s,n){let i;e(this,v)?(t(this,y,r(T,e(this,y),s,n,{context:void 0,listeners:void 0})),i=!e(this,y)):(t(this,w,+e(this,w)-1),i=0===e(this,w)),i&&this.cleanup()}set interop(e){if("boolean"!=typeof e)throw new TypeError("'value' is not a boolean");t(this,v,e)}}const x=(e,t,s,n)=>{const r=n.events;if(r){const s=r[t];if(Array.isArray(s))for(const t of s)t.options.type>e.type&&(e.type=t.options.type)}return e},k=(e,t,s,n)=>{const r=n.events;if(r){const s=r[t];if(Array.isArray(s))for(const n of s)if(n.options.guard)return e.names.push(t),e.guarded=!0,e}return e},T=(e,t,s,n)=>{if(!e)return;const r=n.context,i=n.listeners;let o,a=0;if(t||r||s){for(o=t?[t]:c(e);a<o.length;a++){const n=e[t=o[a]];if(!n)break;const i=[];for(let e=0;e<n.length;e++){const o=n[e];if(s&&s!==o.callback&&s!==o.callback._callback||r&&r!==o.context)i.push(o);else{const e=o.listening;e&&e.off(t,s)}}i.length?e[t]=i:delete e[t]}return e}for(o=c(i);a<o.length;a++)i[o[a]].cleanup()},R=(e,t,s,n)=>{if(s){const r=e[t]||(e[t]=[]),i=n.context,o=n.ctx,c=n.listening,a=JSON.parse(JSON.stringify(n.options));switch(a.guard="boolean"==typeof a.guard&&a.guard,a.type){case"sync":a.type=1;break;case"async":a.type=2;break;default:a.type=0}c&&c.incrementCount(),r.push({callback:s,context:i,ctx:i||o,options:a,listening:c})}return e},O=(e,t,s,r,i,o)=>{let c,a,h=0;if(r&&n.test(r))for(a=r.split(n);h<a.length;h++){const n=e(t,s,a[h],i,o),r=Array.isArray(c)?2:void 0!==c?1:0;if(Array.isArray(n))switch(r){case 0:c=n;break;case 1:c=[c].concat(n);break;case 2:c=c.concat(n)}else if(void 0!==n)switch(r){case 0:c=n;break;case 1:{const e=[c];e.push(n),c=e;break}case 2:c.push(n)}}else c=e(t,s,r,i,o);return c},m=(e,t,s,n,r)=>{let i;if(t){const n=t[s];let o=t.all;n&&o&&(o=o.slice()),n&&(i=e(n,r)),o&&(i=e(o,[s].concat(r)))}return i},D=(e,t)=>{let s,n=-1;const r=t[0],i=t[1],o=t[2],c=e.length;switch(t.length){case 0:for(;++n<c;)(s=e[n]).callback.call(s.ctx);return;case 1:for(;++n<c;)(s=e[n]).callback.call(s.ctx,r);return;case 2:for(;++n<c;)(s=e[n]).callback.call(s.ctx,r,i);return;case 3:for(;++n<c;)(s=e[n]).callback.call(s.ctx,r,i,o);return;default:for(;++n<c;)(s=e[n]).callback.apply(s.ctx,t);return}},S=async(e,t)=>{let s,n=-1;const r=t[0],i=t[1],o=t[2],c=e.length,a=[];switch(t.length){case 0:for(;++n<c;){const t=(s=e[n]).callback.call(s.ctx);void 0!==t&&a.push(t)}break;case 1:for(;++n<c;){const t=(s=e[n]).callback.call(s.ctx,r);void 0!==t&&a.push(t)}break;case 2:for(;++n<c;){const t=(s=e[n]).callback.call(s.ctx,r,i);void 0!==t&&a.push(t)}break;case 3:for(;++n<c;){const t=(s=e[n]).callback.call(s.ctx,r,i,o);void 0!==t&&a.push(t)}break;default:for(;++n<c;){const r=(s=e[n]).callback.apply(s.ctx,t);void 0!==r&&a.push(r)}}return a.length>1?Promise.all(a).then((e=>{const t=e.filter((e=>void 0!==e));switch(t.length){case 0:return;case 1:return t[0];default:return t}})):1===a.length?a[0]:void 0},P=(e,t)=>{let s,n=-1;const r=t[0],i=t[1],o=t[2],c=e.length,a=[];switch(t.length){case 0:for(;++n<c;){const t=(s=e[n]).callback.call(s.ctx);void 0!==t&&a.push(t)}break;case 1:for(;++n<c;){const t=(s=e[n]).callback.call(s.ctx,r);void 0!==t&&a.push(t)}break;case 2:for(;++n<c;){const t=(s=e[n]).callback.call(s.ctx,r,i);void 0!==t&&a.push(t)}break;case 3:for(;++n<c;){const t=(s=e[n]).callback.call(s.ctx,r,i,o);void 0!==t&&a.push(t)}break;default:for(;++n<c;){const r=(s=e[n]).callback.apply(s.ctx,t);void 0!==r&&a.push(r)}}return a.length>1?a:1===a.length?a[0]:void 0},N=(e,t,s={})=>{let n=!1;try{const r=e.isGuarded(t,s);"boolean"==typeof r&&(n=r)}catch(e){n=!1,s.names=[],s.guarded=!1}return n},j=(e,t,s,n)=>{try{e.on(t,s,n)}catch(e){return e}};let _=0;const A=(e="")=>{const t=""+ ++_;return e?`${e}${t}`:t};var J=new WeakMap,W=new WeakMap;class ${constructor(e){J.set(this,{writable:!0,value:void 0}),W.set(this,{writable:!0,value:void 0}),t(this,J,e),Object.seal(this)}before(t,s,n,o,c={}){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");if(!Number.isInteger(t))throw new TypeError("'count' is not an integer");const h={};if(e(this,J).isGuarded(s,h))return console.warn(`@typhonjs-plugin/eventbus ${i(this)}- before() failed as event name(s) are guarded: ${JSON.stringify(h.names)}`),this;const l=r(a,{},s,n,{count:t,after:this.off.bind(this)});return"string"==typeof s&&null==o&&(n=void 0),this.on(l,n,o,c)}destroy(){null!==e(this,J)&&this.off(),t(this,W,void 0),t(this,J,null)}*entries(t){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");for(const s of e(this,J).entries(t))yield s}get eventCount(){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return e(this,J).eventCount}get callbackCount(){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return e(this,J).callbackCount}*keys(t){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");for(const s of e(this,J).keys(t))yield s}*keysWithOptions(t){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");for(const s of e(this,J).keysWithOptions(t))yield s}get isDestroyed(){return null===e(this,J)}get name(){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return`proxy-${e(this,J).name}`}get proxyEventCount(){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return e(this,W)?Object.keys(e(this,W)).length:0}get proxyCallbackCount(){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");if(!e(this,W))return 0;let t=0;for(const s in e(this,W))t+=e(this,W)[s].length;return t}getOptions(t){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return e(this,J).getOptions(t)}getType(t){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return e(this,J).getType(t)}isGuarded(t,s={}){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return e(this,J).isGuarded(t,s)}off(s,n,i){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return t(this,W,r(M,e(this,W)||{},s,n,{context:i,eventbus:e(this,J)})),this}on(s,n,o,c={}){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");if(null==c||c.constructor!==Object)throw new TypeError("'options' must be an object literal.");const a={};if(e(this,J).isGuarded(s,a))return console.warn(`@typhonjs-plugin/eventbus ${i(this)}- on() failed as event name(s) are guarded: ${JSON.stringify(a.names)}`),this;const h={context:o,ctx:this,options:c};return t(this,W,r(C,e(this,W)||{},s,n,h)),e(this,J).on(s,n,h.ctx,c),this}once(t,s,n,o={}){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");const c={};if(e(this,J).isGuarded(t,c))return console.warn(`@typhonjs-plugin/eventbus ${i(this)}- once() failed as event name(s) are guarded: ${JSON.stringify(c.names)}`),this;const h=r(a,{},t,s,{count:1,after:this.off.bind(this)});return"string"==typeof t&&null==n&&(s=void 0),this.on(h,s,n,o)}*proxyEntries(t){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");if(void 0!==t&&!(t instanceof RegExp))throw new TypeError("'regex' is not a RegExp");if(e(this,W))if(t){for(const s in e(this,W))if(t.test(s))for(const t of e(this,W)[s])yield[s,t.callback,t.context,JSON.parse(JSON.stringify(t.options))]}else for(const t in e(this,W))for(const s of e(this,W)[t])yield[t,s.callback,s.context,JSON.parse(JSON.stringify(s.options))]}*proxyKeys(t){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");if(void 0!==t&&!(t instanceof RegExp))throw new TypeError("'regex' is not a RegExp");if(e(this,W))if(t)for(const s in e(this,W))t.test(s)&&(yield s);else for(const t in e(this,W))yield t}*proxyKeysWithOptions(t){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");if(void 0!==t&&!(t instanceof RegExp))throw new TypeError("'regex' is not a RegExp");if(e(this,W))if(t)for(const s in e(this,W))t.test(s)&&(yield[s,e(this,J).getOptions(s)]);else for(const t in e(this,W))yield[t,e(this,J).getOptions(t)]}trigger(t,...s){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return e(this,J).trigger(t,...s),this}triggerAsync(t,...s){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return e(this,J).triggerAsync(t,...s)}triggerDefer(t,...s){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return e(this,J).triggerDefer(t,...s),this}triggerSync(t,...s){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return e(this,J).triggerSync(t,...s)}}const M=(e,t,s,n)=>{if(!e)return;const r=n.context,i=n.eventbus,o=t?[t]:c(e);for(let n=0;n<o.length;n++){const c=e[t=o[n]];if(!c)break;const a=[];for(let e=0;e<c.length;e++){const t=c[e];(s&&s!==t.callback&&s!==t.callback._callback||r&&r!==t.context)&&a.push(t)}a.length?e[t]=a:(i.off(t,s,r),delete e[t])}return e},C=(e,t,s,n)=>{if(s){const r=e[t]||(e[t]=[]),i=n.context,o=n.ctx,c=JSON.parse(JSON.stringify(n.options));switch(c.guard=void 0!==c.guard&&"boolean"==typeof c.guard&&c.guard,c.type){case"sync":c.type=1;break;case"async":c.type=2;break;default:c.type=0}n.ctx=i||o,r.push({callback:s,context:i,ctx:n.ctx,options:c})}return e};var I=new WeakMap,G=new WeakMap;class L{constructor(){I.set(this,{writable:!0,value:void 0}),G.set(this,{writable:!0,value:void 0})}static initialize(s,n){if(void 0!==n&&"string"!=typeof n)throw new TypeError("'name' is not a string.");const r=new L;return t(r,I,s),t(r,G,void 0===n?s.name:n),Object.seal(r),{destroy:function(){r.isDestroyed||(t(r,I,null),this&&(this.eventbusSecure=void 0))},setEventbus:function(s,n){if(void 0!==n&&"string"!=typeof n)throw new TypeError("'name' is not a string.");r.isDestroyed||(void 0===n&&e(r,G)===e(r,I).name?t(r,G,s.name):void 0!==n&&t(r,G,n),t(r,I,s))},eventbusSecure:r}}*keys(t){if(this.isDestroyed)throw new ReferenceError("This EventbusSecure instance has been destroyed.");for(const s of e(this,I).keys(t))yield s}*keysWithOptions(t){if(this.isDestroyed)throw new ReferenceError("This EventbusSecure instance has been destroyed.");for(const s of e(this,I).keysWithOptions(t))yield s}get isDestroyed(){return null===e(this,I)}get name(){if(this.isDestroyed)throw new ReferenceError("This EventbusSecure instance has been destroyed.");return e(this,G)}getOptions(t){if(this.isDestroyed)throw new ReferenceError("This EventbusSecure instance has been destroyed.");return e(this,I).getOptions(t)}getType(t){if(this.isDestroyed)throw new ReferenceError("This EventbusSecure instance has been destroyed.");return e(this,I).getType(t)}trigger(t,...s){if(this.isDestroyed)throw new ReferenceError("This EventbusSecure instance has been destroyed.");return e(this,I).trigger(t,...s),this}triggerAsync(t,...s){if(this.isDestroyed)throw new ReferenceError("This EventbusSecure instance has been destroyed.");return e(this,I).triggerAsync(t,...s)}triggerDefer(t,...s){if(this.isDestroyed)throw new ReferenceError("This EventbusSecure instance has been destroyed.");return e(this,I).triggerDefer(t,...s),this}triggerSync(t,...s){if(this.isDestroyed)throw new ReferenceError("This EventbusSecure instance has been destroyed.");return e(this,I).triggerSync(t,...s)}}const K=new u("mainEventbus"),z=new u("pluginEventbus"),B=new u("testEventbus");export default u;export{$ as EventbusProxy,L as EventbusSecure,K as eventbus,z as pluginEventbus,B as testEventbus};
//# sourceMappingURL=Eventbus.js.map
